\documentclass{llncs}
\usepackage{color}
\usepackage{soul}
\usepackage{cite}
\usepackage{array}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath, amsfonts, url, amssymb, graphics, algorithm2e} 

\usepackage{url}
\newcommand{\starpar}[1]{\par{\footnotesize $\star$ \hl{#1}\par}}
\newcommand{\F}{{\mathbb F}}
\newcommand{\Z}{{\mathbb Z}}

\lstset{basicstyle=\scriptsize,breaklines=true,breakindent=60pt,xleftmargin=20pt,numberstyle=\tiny,numbersep=5pt,language=C}

\begin{document}

\title{Recovering OpenSSL ECDSA Nonces Using the \textsc{Flush+Reload} Cache Side-channel Attack}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
Elliptic curve cryptography~\cite{miller85use,koblitz87elliptic} is a collection of public key cryptographic methods that rely on the computational
intractability of the Elliptic Curve Discrete Logarithm Problem (ECDLP).
In a nutshell, given an elliptic curve over a finite field and two points on the curve~$G$ and~$H$,
the ECDLP is to find the scalar $k$ such that $H=kG$.

Elliptic curve cryptography offers a higher encryption strength per key-bit than similar methods based on 
discreet logarithms over finite field or on number factoring.
Consequently, elliptic curves cryptography uses significantly shorter keys and offers faster operations
than other methods, contributing to the rising popularity of elliptic curves cryptography.

The Elliptic Curve Digital Signature Algorithm (ECDSA)~\cite{johnson01elliptic,fips186,ansi962} is a standard
digital signature algorithm based on elliptic curves.
The core operation of the ECDSA algorithm is multiplying a point on the elliptic curve by a randomly
or pseudo-randomly chosen secret nonce.
The confidentiality of the nonce is paramount for the security of the algorithm.
Past research indicates that partial exposure of nonce bits can be exploited for efficient attacks on the secret key~\cite{nguyen03insecurity,brumley11remote}.

OpenSSL~\cite{openssl} is a cryptographic software package that implements ECDSA.
When using elliptic curves over a binary field $\mathbb{F}_{2^m}$, OpenSSL uses the 
Montgomery ladder~\cite{montgomery87speeding,joye03montgomery} algorithm for multiplying the point by the nonce.
One of the advantages of the Montgomery ladder is that it has regular behaviour, performing
the same sequence of operations for each nonce bit, irrespective of the value of the bit.
This regular behaviour makes it more resilient to side-channel attacks~\cite{joye03montgomery,okeya00elliptic}.

While the operations performed by the algorithm are regular, their targets depend on the value of the bits of the nonce.
To apply the operations to the respective targets, the OpenSSL implementation uses a conditional branch based on the value of the bit.
By tracing this branch an attacker can recover the values of the nonce bits and, consequently, break the cryptosystem.

In this paper we present our 
use the \textsc{Flush+Reload} cache side-channel attack~\cite{yarom13flush}
to trace the branch in the OpenSSL implementation.
\textsc{Flush+Reload} relies on a security weakness in the IA-32 and X86-64 architectures that allows processes
to monitor other processes read and execute access to shared memory pages.
Our attack program monitors access to both arms of the conditional branch and uses the information
collected from these probes to reconstruct the nonce.

The paper also presents new information on the limitation of the \textsc{Flush+Reload} attack.
We discuss spatial limitations, affecting the distance between multiple probes, and 
temporal limitations, affecting the probe resolution.

\starpar{Analysis of partial nonce exposure?}

The rest of this paper is organised as follows.
The next section presents background information on elliptic curves, ECDSA, the Montgomery ladder and the \textsc{Flush+Reload} attack.
Section~\ref{sec:attack} describes our attack on the OpenSSL implementation of ECDSA.
The results of the attack are analysed in Section~\ref{sec:results}.
We discuss the implications of the attack and suggest techniques for mitigation in Section~\ref{sec:discussion}.
Section~\ref{sec:related} presents related research.
\section{Preliminaries}\label{sec:background}

\subsection{ECDSA}\label{sub:ecdsa}

The ElGamal Signature Scheme is the basis of the US 1994 NIST standard, Digital Signature Algorithm (DSA). The ECDSA is the adaptation of one step of the algorithm from the multiplicative group of a finite field to the group of points on an elliptic cure. The main benefit of using this group over field elements is smaller parameters for the same security level as mentioned above. ***

\emph{Parameters:}\quad An elliptic curve $E$ defined over a finite field $\F_{q}$; a point $G\in E$ of large prime order $n$ (generator of the group of points of order $n$). Paramaters chosen as such are generally believed to offer a security level of $\frac{n}{2}$ given current knowledge and technologies. Parameters are recommended to be generated following \cite{fips}. The field size $q$ is usually taken to be a large, odd prime or a power of $2$. The implementation of OpenSSL uses both prime fields and $q=2^m$ though the results in this paper relate to the binary field case.

\emph{Public-Private Key pairs:}\quad the private key is an integer $d$, $1<d<n-1$ and the public key is the point $Q=dG$. Calculating the private key from the public key requires solving the ECDLP, which is known to be hard in practice for the correctly chosen parameters. The most efficient algorithms currently know which solve the ECDLP have a square root run time in the size of the group, hence the aforementioned security level.
\vspace{0.5cm}

Suppose Bob, with public-private Key pair $\{d_B,Q_B\}$, wishes to send a signed message $m$ to Alice, he follows the following steps:
\begin{enumerate}
\item Using an approved hash algorithm, compute $e=Hash(m),$ take $\bar{e}$ to be the leftmost $n$ bits of $e$. ***check fips is leftmost or mod***
\item\label{rand_element} Randomly select $k\leftarrow_R\Z_n$ with $1<k<p-1$ and $(k,p-1)=1$.
\item Compute the point $(x,y)=kG\in E$. ***using montgomery ladder or otherwise***
\item Take $r=x\mod n$; if $r=0$ then return to step \ref{rand_element}.
\item Compute $s=k^{-1}(z+rd_B)\mod n$; if $s=0$ then return to step \ref{rand_element}.
\item Bob sends $(m,r,s)$ to Alice.
\end{enumerate}
The message $m$ is not necessarily encrypted, the contents may not be secret, but a valid signature gives Alice strong evidence that the message was indeed sent by Bob. She verifies that the message came from Bob by 

\begin{enumerate}
\item checking that all received parameters are correct, that $r,s\in\Z_n$ and that Bob's public key is valid, that is $Q_b\neq \mathcal{O}$ and $Q_B\in E$ is of order $n$.
\item Using the same hash function and method as above, compute $\bar{e}$.
\item Compute $\bar{s}=s^{-1}\mod n$.
\item Find the point $(x,y)=\bar{es}G+r\bar{s}Q_B$.
\item Verify that $r=x\mod n$ otherwise reject the signature.
\end{enumerate}

Step \ref{rand_element} of the signing algorithm is of vital importance, inapproproate reuse of the random integer is what lead to the highly publicised breaking of Sony PS3 implementation of ECDSA. Knowledge of the random value $k$ leads to knowledge of the secret key as all values $(m,r,s)$ can be observed by an eavesdropper, $\bar{e}$ can be found from $m$, $r^{-1}\mod n$ can be easily found from $n$, and if $k$ is discovered then an adversary can find Bob's secret key through the simple calculation $$d_B=(sk-\bar{e})r^{-1}.$$

%Using the same value twice (even while keeping k secret), using a predictable value, or leaking even a few bits of k in each of several signatures, is enough to break DSA.

\subsection{The Montgomery Ladder}\label{sub:montgomery}
Scalar multiplication is a common operation in cryptography and in a number of incidences (such as the multiplication by the secret, randomly generated element required in ECDSA), the scalar is intended to remain secret. This scalar multiplication is most efficiently performed using a square-and-multiply method (or the related Right-to-left method) as outlined in Algorithm \ref{d_and_a}

\begin{algorithm}[htb]\label{d_and_a}
\SetAlgoLined
{\bf Input:} Point $P$, scalar $n$, $k$ bits\\
{\bf Output:} Point $nP$\\
$Q\gets \mathcal{O}$\\
 \For{$i$ from $k$ to $0$}{
  $Q\gets 2Q$
  \If{$n_i$ = 0}{
   $Q\gets Q+P$
   }
 }
 \caption{Double-and-Add Point Multiplication}
\end{algorithm}
Double-and-add methods, though efficient, are vulnerable to simple power analysis. The addition law for points on Weirstrass curves is not complete, that is, the computation of $P+Q$ differs between the cases $P=Q$ and $P\neq Q.$ Consequently, by examining the power consumption of the computation it is possible to distingush when the if loop is executed and hence when a bit of $n$ is 0.



As described by Montgomery in \cite{montgomery87speeding}

\begin{algorithm}[htb]
 \SetAlgoLined
% \KwData{this text}
{\bf Input:} Point $P$, scalar $n$, $k$ bits\\
{\bf Output:} Point $nP$\\
% \KwResult{how to write algorithm with \LaTeX2e }
% initialization\;
$R_0\gets \mathcal{O}$\\
$R_1\gets P$\\
 \For{$i$ from $k$ to $0$}{
  \eIf{$n_i$ = 0}{
   $R_1\gets R_0+R_1$\\
   $R_0\gets 2R_0$
   }{
   $R_0\gets R_0+R_1$\\
   $R_1\gets 2R_1$
  }
 }
 \caption{Montgomery Ladder Point Multiplication}
\end{algorithm}

\subsection{The \textsc{Flush+Reload} attack}

Spatial prefetching limits the spatial resolution of the \textsc{Flush+Reload} attack.
When probing a cache line, \textsc{Flush+Reload} issues a read from the line.  
The spatial prefetcher, then, prefetches the pair of the cache line. 
This prefetching prevents using \textsc{Flush+Reload} on the pair of the line,
forcing the spatial resolution to be lower than a probe per two cache lines.

The wait period between flushing and reloading imposes a limit on the temporal resolution of \textsc{Flush+Reload}.
The order of memory accesses occuring during a single wait period cannot be observed.
Thus, shorter wait periods pprovide a higher observation resolution.
On the other hand, with a short wait, a more 

\section{Attacking OpenSSL ECDSA}\label{sec:attack}
OpenSSL is one of the most common open-source cryptographic libraries.
It provides a set of cryptographic services, including public and shared key encryption 
algorithms and public key signature algorithms.

OpenSSL's implementation of ECDSA uses the Montgomery ladder algorithm for scalar multiplication
on the Elliptic Curve.
We use this implementation to demonstrate that na{\"\i}ve implementations of the Montgomery ladder are
susceptible to the \textsc{Flush+Reload} attack.

Listing~\ref{lst:openssl} shows the relevant section of the implementation of the Montgomery ladder in OpenSSL version 1.0.1e.
The bits of the multiplication scalar are stored in the word array \texttt{scalar->d}.
The outer loop, at lines~268 to~286 traverses over the words representing the scalar.
The inner loop, at lines~271 to~284 traverses the bits in each word.
Line~273 tests the bit. 
For each bit the implementation executes a group add followed by a group double.
If the bit is set, the implementation uses lines~275 and~276.
For clear bits it uses lines~280 and~281.

\begin{lstlisting}[numbers=left,firstnumber=268,float=htb,caption=OpenSSL Implementation of the Montgomery Ladder,label=lst:openssl]
for (; i >= 0; i--)
{
    word = scalar->d[i];
    while (mask)
    {
        if (word & mask)
        {
            if (!gf2m_Madd(group, &point->X, x1, z1, x2, z2, ctx)) goto err;
            if (!gf2m_Mdouble(group, x2, z2, ctx)) goto err;
        }
        else
        {
            if (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;
            if (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;
        }
        mask >>= 1;
    }
    mask = BN_TBIT;
}
\end{lstlisting}

As the listing demonstrates, the Implementation is very regular.
For each bit, the implementation executes exactly the same sequence of operations.
The only differences between set and clear bit are the lines that invoke these operations.
While this is a small difference, it is sufficient for mounting an attack that recovers 
the values of the bits.


Our spy program uses the \textsc{Flush+Reload} technique to monitor the execution of the \texttt{if}
statement in line~273.
We distinguish between executing the \texttt{then} and the \texttt{else} blocks of the \texttt{if}
statement.
This information reveals the value of the bit tested by the \texttt{if} statement.

\textsc{Flush+Reload} monitors execution by placing probes on shared memory lines.
For \textsc{Flush+Reload} to recover the bit value, it must distinguish memory lines access sequences
that result from a set bit from those resulting from a clear bit.
Achieveing this depends on several factors: the mapping of source code to memory lines, 
the sequence of accesses to these memory lines when executing the code and 
\textsc{Flush+Reload}'s ability to accurately capture the sequences.


The mapping of source lines to cache lines in our build of OpenSSL is depicted in Diagram~\ref{dgm:memory}.
The machine code created from source lines~273 to~282 covers the virtual memory address range 0x0812130C
to 0x081213e8.
This range spans four cache lines, marked $A$, $B$, $C$ and $D$.


\begin{figure}[htb]
\centering\includegraphics[width=\columnwidth]{images/memory}
\caption{Mapping from Source Code to Memory\label{dgm:memory}}
\end{figure}


The minimum sequence of memory line accesses required for executing this code can now be constructed.
The \texttt{if} statement at line~273 is executed for each bit.  
The code of this statement is in memory line $A$, hence this line is accessed when processing of a bit starts.
For set bit, the processing continues with source line~275, which maps to memory lines~$A$ and~$B$.
The actual call to the group add function occurs at address 0x08121347.
(See mark in Diagram~\ref{dgm:memory}.)
After a delay for computing the group add, execution continues in memory line~$B$ to process the return value and 
to invoke the group doubling function.
The group doubling function returns to memory line~$B$ and execution leaves the \texttt{if} body at memory line~$D$.

Hence, the sequence of memory line accesses required for a set bit is: $A$, $B$, \textit{add}, $B$, \textit{double}, $B$, $D$.
Similarly, for a clear bit, the sequence is: $A$, $C$, \textit{add}, $C$, $D$, \textit{double}, $D$.

Due to the limited temporal resolution of \textsc{Flush+Reload}, the attack can observe the order of memor accesses only
if they are sufficiently separated in time.
Hence, in the case of OpenSSL, the attack can only observe the order of memory accesses if they are separated by a call
to a group operation.
For example, when the bit is set, the attack cannot decide whether the access to memory line~$A$ precedes or follows the access
to memory line~$B$.
Similarly, when observed by \textsc{Flush+Reload}, memory accesses issued after the group double are merged with those 
issued at the start of processing the following bit.
Diagram~\ref{dgm:temporal} shows the memory accesses observable by \textsc{Flush+Reload} when processing a set bit followed by
a clear bit.

\begin{figure}[htb]
\centering\includegraphics[width=\columnwidth]{images/temporal}
\caption{Observable Memory Access over Time\label{dgm:temporal}}
\end{figure}

The diagram also shows memory accessses issued by processor optimisations.
These optimisations pre-load memory lines into the cache to reduce the time the program waits for these lines.
For example, when the processor uses speculative execution~\cite{uht95disjoint}, it follows both arms of a conditional
branch before evaluating the condition.
When the condition is evaluated, the processor commits to the pre-processed computation of the correct arm,
disposing of the computation done for the other arm. 
In the case of OpenSSL this means that even before evaluating the bit, 
the processor may start processing both line~275 and line~280, triggering memory loads from memory lines~$A$, $B$ and $C$.

Another optimisation that can cause additional memory line access is spatial prefetching~\cite{intel12optimization}.
The processor pairs adjacent memory lines and tries to bring both memory lines into the cache
when there is a miss on one of the pair's line.
For example, when there is a cache miss on memory line~$A$, the spatial prefetcher may attempt to prefetch memory line~$B$
and vice versa.

Consequently, as demonstrated in Diagram~\ref{dgm:temporal}, the memory lines accessed between computing
the group add and the group double can be used for recovering the value of the bit.
Probing any of lines~$A$ and~$B$ gives a positive indication of set bits.  
Probing and of lines~$C$ and~$D$ gives a positive indication of clear bits.
For our attack we probe memory lines~$B$ and~$D$.
The next section describes the details of our experiment with the attack and its results.


\subsection{Full recovery of the nonce}\label{sub:full_nonce}
There are a number of attacks on ECC protocols which recover the secret key using a small proportion of the leaked nonce. In this attack, the proportion of the nonce recovered by the \textsc{Flush+Reload} attack is significantly higher; using one of the existing atttacks would be unnecessarily (computationally) excesive. Attacks using lattice techniques to solve the related hidden number problem, for example, ... 
In experiements a basic BSGS implementation sufficed... 

\subsubsection*{Distribution of the missing nonce bits}


\section{Experimental Setup and Results}\label{sec:results}

To test the attack on OpenSSL we used an HP Elite 8300 
running Fedora 18.
As the openssl shipped with Fedora does not support elliptic curves cryptography,
we used our own build of OpenSSL 1.0.1e. 
To facilitate the mapping from source lines to memoryaddresses we built OpenSSL with debugging symbols.
In a real attack settings, the attacker will need to reverse engineer~\cite{cipsero10software}
the OpenSSL library.
For the experiment we used the OpenSSL \texttt{sect1571r1} curve (NIST Binary-Curve B-571~\cite{fips}.)




\starpar{Operation times}
\starpar{Choice of slot size}
\starpar{Example of results}
\starpar{Number of lost bits}
\section{Discussion}\label{sec:discussion}
\starpar{LLL attack}
\starpar{Expected number of observed signatures to break key}
\starpar{Smaller keys are more resilient}~\cite{walter04longer}
\starpar{Mitigation, Dan Bernstein NaCL}
\section{Related Work}\label{sec:related}
\section{Conclusions}

\section{Acknowedgements}
The authors wish to thank Dr Katrina Falkner for the advice and support.

This research was performed under contract to the Defence
Science and Technology Organisation (DSTO) Maritime Division,
Australia.

%\starpar{Bitcoin uses ECDSA}~\cite{nakamoto--bitcoin}

\bibliographystyle{splncs}
\bibliography{Euro2014}

\end{document}

